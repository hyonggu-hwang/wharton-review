{
  "hash": "763afe7e12cde7ea6550f77a89aa6070",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Key Functions\n---\n\n\n\n\nThe goal of this section is to describe the core functions and document the way Toni organized her code. The functions can largely be divded into three categories. First, the *model solver* discretizes the state space, sets up the transition matrix, and solves the model. Second, the *simulation subroutines* simulate the model and collect statistics. Finally, the *estimation* prepares the data for estimation and runs the estimation routine.\n\nThese are some set-ups that will be necessary for the code to run.\n\n::: {#c9e1cfa1 .cell execution_count=3}\n``` {.julia .cell-code code-fold=\"false\"}\n# Think about which file to include this code in eventually.\nusing Random, Distributions, LinearAlgebra, Plots, Statistics, Printf\n```\n:::\n\n\n# 1. Model Solver\nThe goal in this part is to solve the dynamic model via value function iteration (VFI). The code organization is slightly redundant and chaotic in my humble opinion, so I include an overview here. \n\n::: {.column-margin}\nToni has a code script for almost every single function -- this is way too many files! It would be better to group them either into (1) fewer files containing multiple functions, or into (2) separate sub-folders containing individual functions. But to be fair, her readme file is very useful.\n:::\n\nThe code file `valfun.jl` performs the VFI. \n\nA separate file called `collectfunctions.jl` calls the above `valfun.jl` and performs some plotting, interpolation, simulation, and moment generation. To see the entire list of relevant files, please unfold the following code block.\n\n::: {#cdb26f82 .cell execution_count=4}\n``` {.julia .cell-code code-fold=\"true\"}\n# # ============ Stuff that goes into VFI ====================\n# include(\"makegrids.jl\")          # makes the grids\n# include(\"tauchen.jl\")            # makes the transition matrix\n# include(\"profit.jl\")             # makes the profit function\n# include(\"fillin.jl\")             # interpolates the value function. Inefficient. You should make the weights only once. \n# include(\"maxbellman.jl\")         # finds the maximum of the bellman equation\n# include(\"tinybellman.jl\")        # finds the maximum of the bellman equation, within limited bounbds\n# include(\"howard.jl\")             #  Howard's policy improvement algorithm\n# include(\"makepol.jl\")            #  makes the policy function from the index policy function\n# include(\"makeconst.jl\")          #  renormalized the profit function\n# include(\"ptrue.jl\")              #  sets the true parameter values\n# include(\"mew.jl\")                #  makes the stationary distribution. \n# include(\"inbetween.jl\")          #  makes interpolation weights and indices\n# include(\"extract_parameters.jl\") # little helper function to pull parameters out of a vector\n# include(\"update.jl\")             # updates the value function\n\n# # ============ VFI =========================================\n# if settings.fast == true\n#     include(\"valfun.jl\")          # The fast version\n# else\n#     include(\"valfunslow.jl\")      # The slow version\n# end\n# # ============ Plotting and simulation =====================\n# include(\"plotstuff.jl\")    # Self-explanatory\n# include(\"printstuff.jl\")   # Self-explanatory\n# include(\"simmodel.jl\")     # Simulates the model. \n# include(\"interpol.jl\")     # Interpolates the value and policy functions\n\n# # ============Making moments ===============================\n# include(\"momentgen.jl\");   # wrapper\n# include(\"makemoments.jl\"); # Self-explanatory\n```\n:::\n\n\nThe values for the compuational parameters are *separately* defined in `invest_mod.jl`. Using these specific values, Toni then runs all of these files, in another file called `evalfun.jl`. As the name implies, this is where the actual function evaluation is done. This produces the simulated moments for a single parameter combination $(\\alpha, \\delta)$ and the associated comparative statistics outputs.\n\n## Discretization\nThe relevant code files for this step are `tauchen.jl` and `makegrids.jl`. \n\nRecall that the process that governs the evolution of shock $z$ is given as:\n$$\n    \\ln(z') = \\rho \\ln(z) + \\sigma \\varepsilon', \\quad \\varepsilon' \\sim \\mathcal{N}(0, 1)\n$$\n\nUsing the Tauchen method, we can approximate this continuous state space with a discrete Markov chain. The following function implements the Tauchen method to generate a grid of $z$ values and the corresponding transition probabilities. The input parameters for this function are: the autocorrelation `ρ = 0.7`, intercept of the AR1 `μ = 0`, standard deviation of the residual `σ = 0.2`, number of standard deviations `q = 3`, and the number of grid points `N_z = 41`.\n\n::: {#f8ba37e4 .cell execution_count=5}\n``` {.julia .cell-code code-fold=\"true\"}\nfunction tauchen(mew::Float64, sigma::Float64, rho::Float64, znum::Int, q::Float64)\n\n    zstar = mew / (1.0 - rho) #expected value of z\n    sigmaz = sigma / sqrt(1.0 - rho^2) #stddev of z\n\n    z = zstar .+ collect(range(-q * sigmaz, stop=q * sigmaz, length=znum))\n\n\n    trans = zeros(znum, znum)\n    w = (z[2] - z[1])  #Note that all the points are equidistant by construction.\n    for iz in 1:znum\n        for izz in 1:znum\n            binhi = (z[izz] - rho * z[iz] + w / 2.0) / sigma\n            binlo = (z[izz] - rho * z[iz] - w / 2.0) / sigma\n            if izz == 1\n                trans[iz, izz] = cdf(Normal(), binhi)\n            elseif izz == znum\n                trans[iz, izz] = 1.0 - cdf(Normal(), binlo)\n            else\n                trans[iz, izz] = cdf(Normal(), binhi) - cdf(Normal(), binlo)\n            end\n        end\n    end\n\n    return z::Vector{Float64}, trans::Matrix{Float64}\nend\n```\n:::\n\n\nThe output is a vector of $z$ values and a matrix of transition probabilities. Throughout the code, we refer to them as `z_grid` and `trans`, respectively.\n\n::: {#bc5d83e3 .cell execution_count=6}\n``` {.julia .cell-code code-fold=\"true\"}\n# Tauchen parameters\nN_z = 41   # shock grid number\nσ = 0.20   # SD of error term\nμ = 0.0    # AR1 intercept\nρ = 0.70   # AR1 coefficient\nq = 3.0    # 3 standard deviations for the z\n\nz_grid, trans = tauchen(μ, σ, ρ, N_z, q);\nz_grid = exp.(z_grid);\n```\n:::\n\n\nWe discretize the $z$ shock to 41 points.\n\n::: {#ce481b09 .cell execution_count=7}\n``` {.julia .cell-code code-fold=\"false\"}\nprint(z_grid)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.4316379803912925, 0.45015664900394275, 0.46946982853260255, 0.48961160607115856, 0.5106175311603266, 0.5325246785313611, 0.5553717135416735, 0.579198960417851, 0.6040484734265217, 0.6299641110986802, 0.656991613638479, 0.6851786836531056, 0.7145750703462349, 0.7452326573236532, 0.7772055541660273, 0.8105501919304436, 0.8453254227492717, 0.8815926237021424, 0.9194158051443708, 0.9588617236830193, 1.0, 1.0429032417301707, 1.0876471716112988, 1.1343107611320749, 1.182976369914058, 1.2337298910735608, 1.2866609028200269, 1.3418628265584742, 1.3994330917750424, 1.4594733079966673, 1.52208944412838, 1.5873920154847612, 1.6554962788456467, 1.7265224358803595, 1.8005958452994977, 1.877847244108723, 1.9584129783550546, 2.0424352437729247, 2.1300623367547344, 2.2214489160888555, 2.316756275927041]\n```\n:::\n:::\n\n\nThe transition matrix is a 41 x 41 matrix, where element $(i,j)$ represents the probability of moving from state $z_i$ to state $z_j$.\n\n::: {#0e44a3aa .cell execution_count=8}\n``` {.julia .cell-code code-fold=\"false\"}\nsize(trans)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n(41, 41)\n```\n:::\n:::\n\n\nNext, we discretize the capital stock space, so that later on, our policy function contains integers indexing different $K$ values. The upper and lower bounds on $K$ are obtained by plugging in the minimum and maximum values of $z$ into the steady state equation. The Euler equation is given as:\n$$ K = (\\frac{r+δ}{αz})^{1-α}$$\nwhich provides solutions to the equation that sets the marginal product of capital equal to the user cost of capital. \n\nWe discretize $K$ into 501 points. Here is an example from the ``valfunclunky`` code script, where the risk free rate rate is 4\\%, capital depreciation rate `δ = 0.15`, curvature parameter `α = 0.70`, and equity adjustment cost `λ = 0.1`. \n\n::: {#85aa2308 .cell execution_count=9}\n``` {.julia .cell-code code-fold=\"true\"}\n# Dimensions\nN_k = 501\nN_k_pol = 501\n\n# Risk free rate and discount factor\nrf = 0.04\nβ = 1.0 / (1.0 + rf)\n\n# Parameters\nδ = 0.15   # capital depreciation\nα = 0.70   # curvature parameter\nλ = 0.1    # equity adjustment cost\n\n##### Discretize capital \nzmax = maximum(z_grid)\nzmin = minimum(z_grid)\nskale = 0.2 # to make steady state capital stock reasonable\n\n# Euler: plug in min & max of z to get bounds on k\nkminstar = ((rf + δ) / (α * skale * zmin))^(1.0 / (α - 1.0))\nkminstar = log(kminstar)\n\nkmaxstar = ((rf + δ) / (α * skale * zmax))^(1.0 / (α - 1.0))\nkmaxstar = log(kmaxstar)\n\n# Create k grid (and take exponents back)\nk_grid = collect(range(kminstar, stop=kmaxstar, length=N_k))\nk_grid = exp.(k_grid)\n\n# Create k' grid (policy grid)\nk_pol_grid = collect(range(kminstar, stop=kmaxstar, length=N_k_pol))\nk_pol_grid = exp.(k_pol_grid);\n\nprintln(\"Length of the policy grid is \", length(k_pol_grid))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLength of the policy grid is 501\n```\n:::\n:::\n\n\n## Profit Function\nRecall that the firm's objective is to maximize the present value of cash flows to shareholders. For convenience, let's just call this the profit function. As already discussed in the **Model** section, the profit function $E(\\cdot)$ is defined piecewise according to the sign of internal cash flows $E*(\\cdot)$:\n\n$$\n\\begin{align*}\n    E(K, K', z) = \n    \\begin{cases}\n    E^* & \\text{if } E^* \\geq 0 \\\\\n    E^*(1 + \\lambda) & \\text{if } E^* < 0\n    \\end{cases}\n\\end{align*}\n$$\nwhere\n$$\n    E^*(K, K', z) = zK^{\\alpha} - (K' - (1 - \\delta)K).\n$$\n\nThe profit function has three input parameters: current capital stock `K`, next period's capital stock `K'`, and profitability shock `z`. Since these variables have all been discretized, we can fully capture the profit function in a 3D array. The following code fills in this array with the profit function values for different `(z, K, K')` combinations.\n\n::: {#0a5fb965 .cell execution_count=10}\n``` {.julia .cell-code code-fold=\"true\"}\n# Initialize profit array\nprofit = zeros(N_z, N_k, N_k_pol)\n\n# Loop over N_k_pol = 501 values of K' ...\nThreads.@threads for ik_pol in 1:N_k_pol\n\n    # ... and N_k = 501 values of K\n    for ik in 1:N_k\n\n        # ... and N_z = 41 values of z\n        for iz in 1:N_z\n\n            # Profit = internal cash flow if positive\n            profit[iz, ik, ik_pol] =\n                skale * z_grid[iz] * k_grid[ik]^α -\n                (k_pol_grid[ik_pol] - (1.0 - δ) * k_grid[ik])\n\n            # Profit = financing costs in addition if negative    \n            if profit[iz, ik, ik_pol] < 0.0\n                profit[iz, ik, ik_pol] =\n                    profit[iz, ik, ik_pol] * (1.0 + λ)\n            end\n        end\n    end\nend\n\nprintln(\"Size of the profit array is \", size(profit))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSize of the profit array is (41, 501, 501)\n```\n:::\n:::\n\n\nWe have successfully computed the profit function.\n\n::: {.column-margin}\nA nested parallel loop likely causes too much overhead, so I only parallelize the outer loop here.\n:::\n\n## Bellman Equation\nNext, we formulate the Bellman equation and numerically solve the maximization problem. The key relevant files are `valfun.jl` and `maxbellman.jl`, and there are a few more files that implement more advanced computational methods:\n\n- `inbetween.jl`: performs interpolation in a set-up where policy grid is finer than the capital grid (i.e. `N_k_pol` > `N_k`) \n- `howard.jl`: implements Howard's policy improvement algorithm, which is a more efficient way to solve the Bellman equation in earlier iterations of the VFI and when the policy function has already converged\n- `update.jl`: implements McQueen-Porteus algorithm to update the policy and value functions. \n\nFollowing the notation from summer school notes, we can write the Bellman equation as:\n\n::: {.column-margin}\nIn the summer school lecture notes, $E$ corresponds to $R$, $K$ to $s$, and $z$ to $x$.\n:::\n$$ V(K,z) = \\max_{K' \\in \\Gamma(K,z)} \\left[ E(K,z,K') + \\beta \\, \\mathbb{E}_{z'|z} \\, V(K',z') \\right] $$\n\n\nWe already computed $R(\\cdot)$ in the previous step, so let's compute the expectation term. We take the expectation over **all** the next-period states $z'$, for **each** combination of the current state $z$ and the current capital stock $K$. This gives us the next-period value function, which provides a mapping from **all** possible combinations of $z'$ and $K'$ to the .\n\nThe value function is a 2D array of size `N_z x N_k`, where each element corresponds to the value of being in state $(z, K)$.\n\nThe key here is to have the dimensions right: the value function is a 2D array of size `N_z x N_k`, and the transition matrix is a 2D array of size `N_z x N_z`. The following code implements the Bellman equation.\n\n::: {#92ef83b8 .cell execution_count=11}\n``` {.julia .cell-code code-fold=\"true\"}\n# Bellman equation\n\n```\n:::\n\n\n## Value Function Iteration\nThe core of the VFI is to keep updating the value function until it converges to a numerical maximum. To do so, we keep iterating on the Bellman equation until the maximum (absolute) difference between the *current* and *previous* value function is less than a given tolerance level. So, at each iteration, we are really comparing the best value function we have found so far, against the next *candidate* maximum.\n\n\n<!-- The criterion  -->\n\n# 2. Simulation\n\n# 3. Estimation\n\n",
    "supporting": [
      "functions_files"
    ],
    "filters": [],
    "includes": {}
  }
}